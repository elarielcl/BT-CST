/*

Wrapper for Repair -- an implementation of Larsson and Moffat's compression algorithms.
Implementation due to Gonzalo Navarro (balanced version), wrapped for libcds by Alberto Ordóñez. 
You can find the originals at http://www.dcc.uchile.cl/~gnavarro/software/
Copyright (C) 2010-current_year Gonzalo Navarro

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

Author's contact: Gonzalo Navarro, Dept. of Computer Science, University of
Chile. Blanco Encalada 2120, Santiago, Chile. gnavarro@dcc.uchile.cl

Alberto Ordóñez, alberto.ordonez@udc.es

*/

#ifndef REPAIR_H
#define REPAIR_H

#include <utils/libcdsBasics.h>
#include <grammar/irepair.h>

#include <grammar/basicsRepair.h>
#include <grammar/records.h>
#include <grammar/hash.h>
#include <grammar/heap.h>

#define REPAIR_HDR 1
#define REPAIRDN_HDR 2

#define MAX_RULES 1000000

namespace cds_static{
	
	
class Repair{
	public: 
		/**
		 * Builds a grammar considering the input a sequence of chars
		 * */
		Repair(char *input, long len);
		/**
		 * Builds a grammar considering the input a sequence of longs
		 * */
		Repair(int *input, long len);
		/**
		 * Builds a grammar from a bitmap input of length len (len bits in total)
		 * */
		static Repair *instanceFromBitmap(uint *input, long len);

		~Repair();
		/**
		 * Returns the number of non-terminal symbols
		 * */
		long getNTerm();
		/**
		 * Returns the number of rules (not including the number of non-terminals)
		 * */
		long getNRules();
		/**
		 * Returns the length of the sequence C
		 * */
		long getNC();
		/**
		 * Returns the max. value of a non-terminal symbol
		 * */
		long getAlpha();
		/**
		 * Returns the number of terminal symbols
		 * */
		long getTermsSize();
		/**
		 * Returns the left child of the rule "rule"
		 * */
		long getLeft(long rule);
		/**
		 * Returns the right child of the rule "rule"
		 * */
		long getRight(long rule);
		/**
		 * Returns the freq of a rule. When we run the repair algorithm, we always
		 * pick the most frequent pair. That value is what we store.
		 * */
		long getFreqRule(long rule);
		/**
		 * Returns C[pos]
		 * */
		long getC(long pos);
		/**
		 * Returns the size in bits of the grammar: (2*getNC()+getNRules())*bits(getNRules())
		 * */
		long getSize();
		/**
		 * Returns the depth of the grammar. By default it is not computed so the first time
		 * it is called, the computation must be carried out. Then, the result is cached.
		 * */
		long getDepth();
		/**
		 * Prlong the first 50 rules and values of C (if there are more than 50)
		 * */
		void prlong();
		/**
		 * Saves the grammar to a file
		 * */
		virtual void save(ofstream &of);

		static Repair *load(ifstream &fp);
		/**
		* Returns the original length of the sequence
		* */
		long getInputLength();
		/**
		* Returns the length of the chunk generated by a rule. It stores the answers for 
		* all rules in a vector (this vector is LAZY, so the first time we call this function, 
		* the vector is computed).
		* */
		long getLength(long rule);

		bool testRepair(uint *input);
	protected: 
		Repair();
		/*The protected fields correspond to those variables declared in file irepair.c (original implementation)*/
		static const long PRNC = 0;
		static const long PRNR = 0;
		static const long PRNP = 0;
		static const long PRNL = 0;

		long *lengths;//length of each rule

		long nterms;//number of terminal symbols

		long rule_index;//number of rules (nterms not included)

		vector<long> RULES_LEFT;

		vector<long> RULES_RIGHT;

		vector<long> FREQ_PAIRS;

		long grammarDepth;

		static constexpr float factor = 0.75; // 1/extra space overhead; set closer to 1 for smaller and
					 // slower execution
		static constexpr long minsize = 256; // to avoid many reallocs at small sizes, should be ok as is

		long input_len;

		long u; // |text| and later current |C| with gaps

		long *C; // compressed text

		long c;  // real |C|

		int alph; // max used terminal symbol

		int n; // |R|

		Tlist_repair *L; // |L| = c;

		Thash_repair Hash; // hash table of pairs

		Theap_repair Heap; // special heap of pairs

		Trarray_repair Rec; // records

		void saveInternal(ofstream &fp);
		static Repair *loadInternal(ifstream &fp, Repair *ret);
		void prepare (long len);
		void prnSym(long c);
		void prnC (void);
		void prnRec (void);
		void printGrammar();
		long getSym(long c);
		long repair ();
		long computeLengths(long rule, long *lengths);
		long computeGrammarDepth(long rule, long *depths);
		long computeNoccs(long rule, long *noccs);
		void statistics();
		void postRepair();
		virtual void runRepair(char *input, long len);
		virtual void runRepair(uint *input, long len);
		void deleteAll();
		bool testExpand(long rule, long &p, uint *input);

		bool researchStats();
		
};

};

#include <grammar/RepairDN.h>
#endif



// /*

// Wrapper for Repair -- an implementation of Larsson and Moffat's compression algorithms.
// Implementation due to Gonzalo Navarro (balanced version), wrapped for libcds by Alberto Ordóñez. 
// You can find the originals at http://www.dcc.uchile.cl/~gnavarro/software/
// Copyright (C) 2010-current_year Gonzalo Navarro

// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Author's contact: Gonzalo Navarro, Dept. of Computer Science, University of
// Chile. Blanco Encalada 2120, Santiago, Chile. gnavarro@dcc.uchile.cl

// Alberto Ordóñez, alberto.ordonez@udc.es

// */

// #ifndef REPAIR_H
// #define REPAIR_H

// #include <utils/libcdsBasics.h>
// #include <irepair.h>

// #include <grammar/basicsRepair.h>
// #include <grammar/records.h>
// #include <grammar/hash.h>
// #include <grammar/heap.h>


// #define MAX_RULES 10000000

// namespace cds_static{

// #ifndef relong
// #define relong long long
// #endif
	
// class Repair{
// 	public: 
// 		/**
// 		 * Builds a grammar considering the input a sequence of chars
// 		 * */
// 		Repair(char *input, ulong len);
// 		/**
// 		 * Builds a grammar considering the input a sequence of longs
// 		 * */
// 		Repair(long *input, ulong len);
// 		/**
// 		 * Builds a grammar from a bitmap input of length len (len bits in total)
// 		 * */
// 		static Repair *instanceFromBitmap(ulong *input, ulong len);

// 		~Repair();
// 		/**
// 		 * Returns the number of non-terminal symbols
// 		 * */
// 		long getNTerm();
// 		/**
// 		 * Returns the number of rules (not including the number of non-terminals)
// 		 * */
// 		long getNRules();
// 		/**
// 		 * Returns the length of the sequence C
// 		 * */
// 		long getNC();
// 		/**
// 		 * Returns the max. value of a non-terminal symbol
// 		 * */
// 		long getAlpha();
// 		/**
// 		 * Returns the number of terminal symbols
// 		 * */
// 		long getTermsSize();
// 		/**
// 		 * Returns the left child of the rule "rule"
// 		 * */
// 		long getLeft(long rule);
// 		/**
// 		 * Returns the right child of the rule "rule"
// 		 * */
// 		long getRight(long rule);
// 		/**
// 		 * Returns the freq of a rule. When we run the repair algorithm, we always
// 		 * pick the most frequent pair. That value is what we store. 
// 		 * */
// 		long getFreqRule(long rule);
// 		*
// 		 * Returns C[pos]
// 		 * 
// 		long getC(long pos);
// 		/**
// 		 * Returns the size in bits of the grammar: (2*getNC()+getNRules())*bits(getNRules())
// 		 * */
// 		size_t getSize();
// 		/**
// 		 * Returns the depth of the grammar. By default it is not computed so the first time
// 		 * it is called, the computation must be carried out. Then, the result is cached. 
// 		 * */
// 		size_t getDepth();
// 		/**
// 		 * Prlong the first 50 rules and values of C (if there are more than 50)
// 		 * */
// 		void prlong();
// 		/**
// 		 * Saves the grammar to a file
// 		 * */
// 		void save(ofstream &of);
// 		/**
// 		* Returns the original length of the sequence
// 		* */
// 		ulong getInputLength();
// 		/**
// 		* Returns the length of the chunk generated by a rule. It stores the answers for 
// 		* all rules in a vector (this vector is LAZY, so the first time we call this function, 
// 		* the vector is computed).
// 		* */
// 		ulong getLength(ulong rule);

// 	protected: 
// 		Repair();
// 		/*The protected fields correspond to those variables declared in file irepair.c (original implementation)*/
// 		static const long PRNC = 0;
// 		static const long PRNR = 0;
// 		static const long PRNP = 0;
// 		static const long PRNL = 0;

// 		long *text; // first pass over this long array

// 		long MB;

// 		long did0; // did prepare0 or not

// 		long *lengths;//length of each rule

// 		long nterms;//number of terminal symbols

// 		long rule_index;//number of rules (nterms not included)

// 		long *RULES_LEFT;

// 		long *RULES_RIGHT;
		
// 		long *FREQ_PAIRS;
		
// 		long grammarDepth;

// 		static constexpr float factor = 0.75; // 1/extra space overhead; set closer to 1 for smaller and
// 					 // slower execution
// 		static constexpr long minsize = 256; // to avoid many reallocs at small sizes, should be ok as is

// 		ulong input_len;

// 		long u; // |text| and later current |C| with gaps

// 		relong *C; // compressed text

// 		long c;  // real |C|

// 		long alph; // max used terminal symbol

// 		long n; // |R|

// 		Tlist_repair *L; // |L| = c;

// 		Thash_repair Hash; // hash table of pairs

// 		Theap_repair Heap; // special heap of pairs

// 		Trarray_repair Rec; // records
		
// 		void prepare (long len);
// 		void prepare0(relong len);
// 		void prnSym(long c);
// 		void prnC (void);
// 		void prnRec (void);
// 		void prlongGrammar();
// 		long getSym(long c);
// 		relong repair ();
// 		relong repair0 (relong len);
// 		long computeLengths(long rule, long *lengths);
// 		long computeGrammarDepth(long rule, long *depths);
// 		long computeNoccs(long rule, long *noccs);
// 		void statistics();
// 		void postRepair();
// 		void runRepair(char *input, ulong len);
// 		void runRepair(long *input, ulong len);
// 		void deleteAll();
// 		bool testExpand(long rule, ulong &p, long *input);
// 		bool testRepair(long *input);
// 		bool researchStats();
		
// };

// };
// #endif

